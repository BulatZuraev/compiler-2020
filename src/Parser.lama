-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  s (l) |> lift (p |> bypass (s (r)))
}

fun incurl(p) {
  inbr("(", p, ")")
}

fun makeOps() {
  local binopsMap = {
    [singleton("!!"), Left],
    [singleton("&&"), Left],
    [{"==", "!=", "<=", "<", ">=", ">"}, Nona],
    [{"+", "-"}, Left],
    [{"*", "/", "%"}, Left] 
  };

  fun toPair(op) {
    [s(op), fun (l, r) {Binop(op, l, r)}]
  }

  fun transform([list, ass]) {
    [ass, map(toPair, list)]
  }

  map(
    transform,
    binopsMap
  )
}

local ops = makeOps();

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            incurl (exp)),
      exp = memo $ eta (expr(ops, primary)(id));

local basicStmt = memo $ eta (kSkip @ lift(Skip) |
                              kRead  |> lift(incurl(lident) @ fun (x) {Read (x)}) |
                              kWrite |> lift(exp @ fun (x) {Write (x)}) |
                              lident |> fun (x) {
                                                  (s(":=") |> lift(exp)) @ fun (expr) {Assn (x, expr)}
                                                });

local stmt = memo $ eta(basicStmt |
                        basicStmt |> fun (basic) {
                                                   (s(";") |> lift(stmt)) @ fun (basics) {Seq (basic, basics)}
                                                 }); 

-- Public top-level parser
public parse = stmt;
             
